It is no longer necessary to subclass the supplied ''!-FitLibrary-!'' fixtures. Subclassing those fixtures has meant that:
 * You sometimes have to duplicate code in several different fixture subclasses
 * Your class inherits a lot of methods that are irrelevant to you.
 * These extra methods clutter up method name continuations in Eclipse and other IDEs.
 * You may override a fixture superclass method by mistake, leading to weird behaviour (such as the method ''right()'')
Now, a ''System Under Test'' (''SUT'') object can do all the work.
!3 What's a ''SUT''?
For many releases now, a ''!-FitLibrary-!'' fixture may in turn refer to a SUT. Most of the fixtures can take a SUT as an argument. Eg, in Java:
{{{ public CalculateFixture verify() {
     return new CalculateFixture(myDomainObject);
}
}}} In general, a ''!-FitLibrary-!'' fixture works by first checking for a method in the fixture itself. If it's not there, it then checks in the ''SUT''. This means that the fixture acts as an adapter to the SUT, supplying methods only when it's necessary for special fixturing work, such as:
 * Changing the name of a method, because the one generated by ''!-FitLibrary-!'' from the table headers, etc is awkward
 * Handling reordering of changes to the arguments and/or return values of a method
 * Providing special methods that are needed with nested tables for set up (''find''/''show'' methods)
!3 ''!-DomainAdapter-!''
A SUT may be a ''!-DomainAdapter-!'', which supplies adapter methods and in turn refers to a SUT (or null).

Instead of subclassing a fixture to provide adapter methods, now create a class that implements ''!-DomainAdapter-!''. Pass this as an argument to a suitable ''!-FitLibrary-!'' fixture. Eg, in Java:
{{{ public CalculateFixture verify() {
     return new CalculateFixture(myDomainAdapter);
}
}}} Using a ''DomainAdapter'':
 * Your ''DomainAdapter'' classes can be arranged in a subclass hierarchy that allows for code sharing
 * There are no longer superfluous framework methods being inherited
 * Your ''DomainAdapter'' class can define MethodNameMappings
Chains of SUTs are permitted: A ''!-DomainAdapter-!'' may in turn refer to a ''!-DomainAdapter-!'' as its SUT.
!3 Examples
For examples, see [[''chat code''][.FitLibrary.UserGuide.FitLibraryByExample.WorkFlow.WorkflowCode]]